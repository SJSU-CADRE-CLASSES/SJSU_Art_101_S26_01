<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MediaPipe Skeleton Tracker (Pose)</title>
    <style>
      :root {
        --bg: #0b0d12;
        --panel: rgba(255, 255, 255, 0.06);
        --panel-border: rgba(255, 255, 255, 0.12);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --accent: #7c5cff;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        color: var(--text);
        background:
          radial-gradient(1200px 800px at 10% 10%, rgba(124, 92, 255, 0.18), transparent 55%),
          radial-gradient(900px 600px at 90% 20%, rgba(0, 224, 255, 0.14), transparent 50%),
          radial-gradient(900px 600px at 50% 90%, rgba(255, 94, 131, 0.10), transparent 50%),
          var(--bg);
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 20px 16px 40px;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px 16px;
        margin-bottom: 14px;
      }

      h1 {
        font-size: 1.2rem;
        margin: 0;
        letter-spacing: 0.2px;
      }

      .sub {
        color: var(--muted);
        font-size: 0.95rem;
        margin: 0;
      }

      .grid {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 14px;
      }

      @media (max-width: 980px) {
        .grid { grid-template-columns: 1fr; }
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 14px;
        padding: 14px;
        backdrop-filter: blur(10px);
      }

      .controls {
        display: grid;
        gap: 12px;
      }

      .row {
        display: grid;
        gap: 8px;
      }

      .row.inline {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        font-size: 0.95rem;
        color: var(--text);
      }

      label small {
        color: var(--muted);
        font-weight: 500;
      }

      input[type="range"] { width: 100%; }
      input[type="color"] { width: 42px; height: 28px; padding: 0; border: 0; background: transparent; }

      .btns {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        font-weight: 650;
        letter-spacing: 0.2px;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      }

      button:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.28); }
      button:active { transform: translateY(0px); }
      button.primary {
        border-color: rgba(124, 92, 255, 0.55);
        background: linear-gradient(135deg, rgba(124, 92, 255, 0.60), rgba(124, 92, 255, 0.18));
      }

      .status {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.88rem;
        color: var(--muted);
        line-height: 1.4;
        white-space: pre-wrap;
      }

      .stage {
        position: relative;
        overflow: hidden;
        padding: 0;
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        background: rgba(0, 0, 0, 0.22);
        border-radius: 14px;
      }

      .hint {
        color: var(--muted);
        font-size: 0.95rem;
        margin: 0;
      }

      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.85em;
        padding: 2px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.18);
        background: rgba(255,255,255,0.08);
        color: var(--text);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Skeleton Tracker (MediaPipe Pose)</h1>
          <p class="sub">Webcam → pose landmarks → stick-figure skeleton on canvas</p>
        </div>
        <p class="sub">Tip: run from a local server (not <span class="kbd">file://</span>).</p>
      </header>

      <div class="grid">
        <section class="panel controls" aria-label="controls">
          <div class="btns">
            <button id="start" class="primary" type="button">Start camera</button>
            <button id="stop" type="button" disabled>Stop</button>
          </div>

          <p class="hint">
            If the camera is blocked, check browser permissions or use Chrome/Edge.
          </p>

          <div class="row">
            <label>
              <span>Mirror (selfie mode)</span>
              <input id="mirror" type="checkbox" checked />
            </label>
            <label>
              <span>Show video background</span>
              <input id="showVideo" type="checkbox" checked />
            </label>
          </div>

          <div class="row inline">
            <label>
              <span>Line color</span>
              <input id="lineColor" type="color" value="#7c5cff" />
            </label>
            <label>
              <span>Point color</span>
              <input id="pointColor" type="color" value="#00e0ff" />
            </label>
          </div>

          <div class="row">
            <label>
              <span>Line width</span>
              <small><span id="lineWidthLabel">4</span> px</small>
            </label>
            <input id="lineWidth" type="range" min="1" max="12" step="1" value="4" />
          </div>

          <div class="row">
            <label>
              <span>Point size</span>
              <small><span id="pointSizeLabel">6</span> px</small>
            </label>
            <input id="pointSize" type="range" min="1" max="14" step="1" value="6" />
          </div>

          <div class="row">
            <label>
              <span>Confidence threshold</span>
              <small><span id="confLabel">0.50</span></small>
            </label>
            <input id="conf" type="range" min="0" max="1" step="0.01" value="0.50" />
          </div>

          <div class="status" id="status" aria-live="polite">Loading…</div>
        </section>

        <section class="panel stage" aria-label="canvas stage">
          <canvas id="canvas"></canvas>
          <video id="video" playsinline muted style="display:none;"></video>
        </section>
      </div>
    </div>

    <script type="module">
      import {
        FilesetResolver,
        PoseLandmarker
      } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/+esm";

      const WASM_BASE_URL = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm/";
      const MODEL_URL =
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";

      // Pose landmark indices (MediaPipe Pose: 33 points)
      // https://developers.google.com/mediapipe/solutions/vision/pose_landmarker
      const CONNECTIONS = [
        // arms
        [11, 13], [13, 15], // left shoulder → elbow → wrist
        [12, 14], [14, 16], // right shoulder → elbow → wrist
        // shoulders / torso
        [11, 12],           // left shoulder ↔ right shoulder
        [11, 23], [12, 24], // shoulders → hips
        [23, 24],           // left hip ↔ right hip
        // legs
        [23, 25], [25, 27], // left hip → knee → ankle
        [24, 26], [26, 28], // right hip → knee → ankle
        // feet
        [27, 31], [31, 29], [29, 27], // left ankle ↔ heel ↔ foot index
        [28, 32], [32, 30], [30, 28], // right ankle ↔ heel ↔ foot index
        // simple head / neck
        [0, 11], [0, 12],   // nose to shoulders (stylized)
        [7, 8],             // left ear ↔ right ear
        [9, 10],            // mouth left ↔ mouth right
        [0, 9], [0, 10]     // nose → mouth corners
      ];

      const els = {
        start: document.getElementById("start"),
        stop: document.getElementById("stop"),
        mirror: document.getElementById("mirror"),
        showVideo: document.getElementById("showVideo"),
        lineColor: document.getElementById("lineColor"),
        pointColor: document.getElementById("pointColor"),
        lineWidth: document.getElementById("lineWidth"),
        pointSize: document.getElementById("pointSize"),
        conf: document.getElementById("conf"),
        lineWidthLabel: document.getElementById("lineWidthLabel"),
        pointSizeLabel: document.getElementById("pointSizeLabel"),
        confLabel: document.getElementById("confLabel"),
        status: document.getElementById("status"),
        canvas: document.getElementById("canvas"),
        video: document.getElementById("video"),
      };

      const ctx = els.canvas.getContext("2d");

      let poseLandmarker = null;
      let stream = null;
      let running = false;
      let rafId = 0;
      let lastFpsT = performance.now();
      let frames = 0;
      let fps = 0;

      function setStatus(lines) {
        els.status.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines);
      }

      function updateLabels() {
        els.lineWidthLabel.textContent = els.lineWidth.value;
        els.pointSizeLabel.textContent = els.pointSize.value;
        els.confLabel.textContent = Number(els.conf.value).toFixed(2);
      }
      updateLabels();
      els.lineWidth.addEventListener("input", updateLabels);
      els.pointSize.addEventListener("input", updateLabels);
      els.conf.addEventListener("input", updateLabels);

      function resizeCanvasToVideo() {
        const vw = els.video.videoWidth || 1280;
        const vh = els.video.videoHeight || 720;
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

        els.canvas.width = Math.floor(vw * dpr);
        els.canvas.height = Math.floor(vh * dpr);
        els.canvas.style.aspectRatio = `${vw} / ${vh}`;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      }

      function clear() {
        const w = els.canvas.width / (window.devicePixelRatio || 1);
        const h = els.canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
      }

      function draw(results) {
        const vw = els.video.videoWidth || 1280;
        const vh = els.video.videoHeight || 720;

        // canvas draws in CSS pixels because we setTransform(dpr,...)
        clear();

        const mirror = els.mirror.checked;
        const showVideo = els.showVideo.checked;

        ctx.save();
        if (mirror) {
          ctx.translate(vw, 0);
          ctx.scale(-1, 1);
        }

        if (showVideo) {
          ctx.globalAlpha = 0.95;
          ctx.drawImage(els.video, 0, 0, vw, vh);
          ctx.globalAlpha = 1;
        }

        ctx.restore();

        const pose = results?.landmarks?.[0];
        if (!pose || pose.length < 33) return;

        const conf = Number(els.conf.value);
        const lineW = Number(els.lineWidth.value);
        const pointR = Number(els.pointSize.value);
        const lineColor = els.lineColor.value;
        const pointColor = els.pointColor.value;

        function px(i) {
          const lm = pose[i];
          if (!lm) return null;
          const vis = (lm.visibility ?? lm.presence ?? 1);
          if (vis < conf) return null;
          const xNorm = mirror ? (1 - lm.x) : lm.x;
          return { x: xNorm * vw, y: lm.y * vh };
        }

        // lines
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = lineW;

        ctx.beginPath();
        for (const [a, b] of CONNECTIONS) {
          const A = px(a);
          const B = px(b);
          if (!A || !B) continue;
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
        }
        ctx.stroke();

        // points
        ctx.fillStyle = pointColor;
        for (let i = 0; i < pose.length; i++) {
          const P = px(i);
          if (!P) continue;
          ctx.beginPath();
          ctx.arc(P.x, P.y, pointR, 0, Math.PI * 2);
          ctx.fill();
        }

        // FPS
        frames++;
        const t = performance.now();
        if (t - lastFpsT > 600) {
          fps = Math.round((frames * 1000) / (t - lastFpsT));
          frames = 0;
          lastFpsT = t;
        }

        ctx.fillStyle = "rgba(0,0,0,0.45)";
        ctx.fillRect(12, 12, 132, 34);
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
        ctx.fillText(`FPS: ${fps}`, 22, 34);
      }

      async function initPose() {
        setStatus([
          "Downloading MediaPipe WASM + Pose model…",
          "If this hangs, refresh and try again."
        ]);
        const vision = await FilesetResolver.forVisionTasks(WASM_BASE_URL);
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: MODEL_URL,
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
        setStatus([
          "Ready.",
          "Press “Start camera” to begin."
        ]);
      }

      async function start() {
        if (!poseLandmarker) await initPose();
        if (!navigator.mediaDevices?.getUserMedia) {
          setStatus([
            "Error: getUserMedia not supported in this browser.",
            "Try Chrome or Edge."
          ]);
          return;
        }
        if (location.protocol !== "https:" && location.hostname !== "localhost") {
          setStatus([
            "Camera requires a secure context.",
            "Run from https:// or http://localhost (local server)."
          ]);
          // We still try; some browsers allow it, but usually this is the cause.
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });

        els.video.srcObject = stream;
        await els.video.play();
        resizeCanvasToVideo();

        running = true;
        els.start.disabled = true;
        els.stop.disabled = false;

        setStatus([
          "Tracking…",
          "Try stepping back so your full body is visible."
        ]);

        const loop = () => {
          if (!running) return;
          const now = performance.now();
          const results = poseLandmarker.detectForVideo(els.video, now);
          draw(results);
          rafId = requestAnimationFrame(loop);
        };
        loop();
      }

      async function stop() {
        running = false;
        cancelAnimationFrame(rafId);
        rafId = 0;

        if (els.video) {
          els.video.pause();
          els.video.srcObject = null;
        }

        if (stream) {
          for (const track of stream.getTracks()) track.stop();
          stream = null;
        }

        els.start.disabled = false;
        els.stop.disabled = true;

        clear();
        setStatus([
          "Stopped.",
          "Press “Start camera” to begin again."
        ]);
      }

      els.start.addEventListener("click", () => start().catch(err => {
        console.error(err);
        setStatus([
          "Error starting camera / tracker:",
          String(err?.message || err),
          "",
          "Common fixes:",
          "- Run from a local server (http://localhost), not file://",
          "- Allow camera permission in the browser",
          "- Close other apps using the camera"
        ]);
        els.start.disabled = false;
        els.stop.disabled = true;
      }));
      els.stop.addEventListener("click", () => stop().catch(console.error));

      window.addEventListener("resize", () => {
        if (els.video.videoWidth) resizeCanvasToVideo();
      });

      // First load
      setStatus([
        "Loading MediaPipe…",
        "This page will download a small WASM runtime + a pose model."
      ]);
      initPose().catch(err => {
        console.error(err);
        setStatus([
          "Failed to initialize MediaPipe Pose:",
          String(err?.message || err),
          "",
          "If you’re offline, the CDN/model download won’t work."
        ]);
      });
    </script>
  </body>
</html>

