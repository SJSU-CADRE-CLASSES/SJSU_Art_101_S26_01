<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DIGITAL RESIDUE — Visualization</title>
  <link rel="stylesheet" href="./style.css?v=1013">

  <!-- Pulse overlay (doesn't interfere with moving blobs) -->
  <style>
    #pulse-overlay{
      position:fixed;
      left:0; top:0;
      width:140px; height:140px;
      border-radius:50%;
      pointer-events:none;
      opacity:0;
      z-index:9999;
      filter: blur(16px) saturate(2.4);
      transform: translate(-9999px, -9999px) scale(1);
      will-change: transform, opacity;
    }
    #pulse-overlay.on{
      animation: pulseFill 650ms ease-out 1;
    }
    @keyframes pulseFill{
      0%   { opacity:0.95; transform: translate(var(--px), var(--py)) scale(1); }
      55%  { opacity:0.95; transform: translate(var(--px), var(--py)) scale(10); }
      100% { opacity:0;    transform: translate(var(--px), var(--py)) scale(10); }
    }
    @media (prefers-reduced-motion: reduce){
      #pulse-overlay.on{ animation:none; opacity:0; }
    }
  </style>
</head>

<body data-page="viz">

<a class="back" href="./index.html">← BACK</a>

<h1 class="viz-title">MY SCREEN TIME</h1>
<p class="viz-sub">TAP / CLICK A COLOR BLOB TO REVEAL THE APP + SCREENTIME.</p>

<div id="blob-stage"></div>
<div id="tip" class="tip"></div>

<!-- NEW: pulse layer -->
<div id="pulse-overlay"></div>

<script src="./data.js?v=1013"></script>

<script>
(() => {
  const stage = document.getElementById("blob-stage");
  const tip = document.getElementById("tip");
  const pulse = document.getElementById("pulse-overlay");
  const ITEMS = (typeof APPS !== "undefined") ? APPS : [];

  if (!ITEMS.length) {
    stage.innerHTML = `<p style="opacity:.7">No APPS data found in data.js.</p>`;
    return;
  }

  window.addEventListener("load", () => requestAnimationFrame(init), { once:true });

  function init(){
    // ===== TUNING =====
    const PAD = 24;

    // keep them apart (including blur)
    const GAP = 230;          // circle spacing
    const VISUAL_GAP = 110;   // blur buffer (bigger = less blending)

    // stronger solver so they don't merge
    const SOLVER_PASSES = 26;
    const SEPARATE_RATIO = 0.90;

    // add gentle velocity repulsion so they don't "stick"
    const REPEL = 0.012;

    // motion
    const DAMP = 0.996;       // glide
    const BOUNCE = 1.01;
    const MAX_SPEED = 8.2;
    const MIN_SPEED = 4.6;
    const STEER = 0.090;

    // roaming targets
    const RETARGET_MS = 1500;
    const ARRIVE = 320;

    // tiny organic drift so it never looks frozen
    const WOBBLE = 0.045;

    // tooltip timing (your request)
    const TIP_MS = 1000;

    const maxH = Math.max(...ITEMS.map(x => Number(x.hours || 0)), 1);

    const blobs = [];
    const placed = [];
    let tipTimer = null;

    function showTip(text, x, y){
      if (tipTimer) { clearTimeout(tipTimer); tipTimer = null; }

      tip.textContent = text;
      tip.style.opacity = "1";

      if (typeof x === "number" && typeof y === "number"){
        tip.style.left = (x + 14) + "px";
        tip.style.top  = (y + 14) + "px";
      }

      tipTimer = setTimeout(() => {
        tip.style.opacity = "0";
        document.querySelectorAll(".blob").forEach(b => b.classList.remove("active"));
        tipTimer = null;
      }, TIP_MS);
    }

    function clearTip(){
      if (tipTimer) { clearTimeout(tipTimer); tipTimer = null; }
      tip.style.opacity = "0";
      document.querySelectorAll(".blob").forEach(b => b.classList.remove("active"));
    }

    function getBounds(){
      const rect = stage.getBoundingClientRect();
      return {
        rect,
        minX: PAD,
        minY: PAD,
        maxXFor: (size) => rect.width  - size - PAD,
        maxYFor: (size) => rect.height - size - PAD,
      };
    }

    function randTarget(size){
      const b = getBounds();
      const maxX = Math.max(b.maxXFor(size), b.minX);
      const maxY = Math.max(b.maxYFor(size), b.minY);
      return {
        tx: b.minX + Math.random() * Math.max(maxX - b.minX, 1),
        ty: b.minY + Math.random() * Math.max(maxY - b.minY, 1),
      };
    }

    function tryPlace(sizePx){
      const b = getBounds();
      const r = sizePx/2;

      const maxX = Math.max(b.maxXFor(sizePx), b.minX);
      const maxY = Math.max(b.maxYFor(sizePx), b.minY);

      for (let attempt = 0; attempt < 2600; attempt++){
        const x = b.minX + Math.random() * Math.max(maxX - b.minX, 1);
        const y = b.minY + Math.random() * Math.max(maxY - b.minY, 1);

        const cx = x + r;
        const cy = y + r;

        let ok = true;
        for (const p of placed){
          const dist = Math.hypot(cx - p.cx, cy - p.cy);
          const minDist = r + p.r + GAP + VISUAL_GAP;
          if (dist < minDist){ ok=false; break; }
        }
        if (ok){
          placed.push({cx, cy, r});
          return {x, y};
        }
      }

      return {
        x: b.minX + Math.random() * Math.max(maxX - b.minX, 1),
        y: b.minY + Math.random() * Math.max(maxY - b.minY, 1),
      };
    }

    // pulse on overlay (always works, never blocks)
    function triggerPulseOverlay(color, x, y){
      pulse.style.background = `radial-gradient(circle, ${color} 0%, rgba(255,255,255,0) 62%)`;
      pulse.style.setProperty("--px", `${x}px`);
      pulse.style.setProperty("--py", `${y}px`);
      pulse.classList.remove("on");
      void pulse.offsetWidth;
      pulse.classList.add("on");
    }

    // build blobs
    ITEMS.forEach((item, idx) => {
      const h = Number(item.hours || 0);

      const size = 240 + (h/maxH) * 360;
      const r = size/2;

      const el = document.createElement("div");
      el.className = "blob";
      el.style.width = size + "px";
      el.style.height = size + "px";
      el.style.background = `radial-gradient(circle, ${item.color} 0%, rgba(255,255,255,0) 52%)`;

      stage.appendChild(el);

      const pos = tryPlace(size);

      // start with real velocity so it's visibly moving immediately
      const ang = Math.random() * Math.PI * 2;
      const sp  = MIN_SPEED + Math.random() * 2.0;

      const t = randTarget(size);

      blobs.push({
        el, size, r,
        x: pos.x, y: pos.y,
        vx: Math.cos(ang) * sp,
        vy: Math.sin(ang) * sp,
        tx: t.tx, ty: t.ty,
        nextTargetAt: performance.now() + (Math.random() * RETARGET_MS),
        phase: Math.random() * Math.PI * 2,
        label: `${item.app} — ${h.toFixed(1)} HOURS`,
        color: item.color
      });

      el.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();

        document.querySelectorAll(".blob").forEach(b => b.classList.remove("active"));
        el.classList.add("active");

        // overlay pulse at the blob's CURRENT sim position (not mouse)
        const o = blobs[idx];
        triggerPulseOverlay(o.color, o.x, o.y);

        showTip(o.label, e.clientX, e.clientY);
      });
    });

    // click empty area clears tip
    stage.addEventListener("pointerdown", (e)=>{
      if (e.target === stage) clearTip();
    });

    // resize: re-target so movement stays healthy
    window.addEventListener("resize", () => {
      blobs.forEach(o => {
        const t = randTarget(o.size);
        o.tx = t.tx; o.ty = t.ty;
        o.nextTargetAt = performance.now() + (Math.random() * RETARGET_MS);
      });
    });

    function animate(now){
      const b = getBounds();

      // 1) steering + wobble (ensures constant drift)
      blobs.forEach(o => {
        if (now >= o.nextTargetAt){
          const t = randTarget(o.size);
          o.tx = t.tx; o.ty = t.ty;
          o.nextTargetAt = now + RETARGET_MS * (0.8 + Math.random() * 0.7);
        }

        const dx = (o.tx - o.x);
        const dy = (o.ty - o.y);
        const dist = Math.hypot(dx, dy) || 0.0001;

        const desiredSpeed = Math.min(MAX_SPEED, Math.max(MIN_SPEED, (dist / ARRIVE) * MAX_SPEED));
        const ux = dx / dist;
        const uy = dy / dist;

        const desiredVx = ux * desiredSpeed;
        const desiredVy = uy * desiredSpeed;

        o.vx += (desiredVx - o.vx) * STEER;
        o.vy += (desiredVy - o.vy) * STEER;

        // wobble keeps it alive (prevents "stuck" look)
        o.phase += 0.02;
        o.vx += Math.cos(o.phase) * WOBBLE;
        o.vy += Math.sin(o.phase * 1.13) * WOBBLE;

        // clamp min/max speed
        const sp = Math.hypot(o.vx, o.vy) || 0.0001;
        if (sp > MAX_SPEED){
          const s = MAX_SPEED / sp;
          o.vx *= s; o.vy *= s;
        } else if (sp < MIN_SPEED){
          const s = MIN_SPEED / sp;
          o.vx *= s; o.vy *= s;
        }
      });

      // 2) collision solver (position + velocity repel)
      for (let pass = 0; pass < SOLVER_PASSES; pass++){
        for (let i=0; i<blobs.length; i++){
          for (let j=i+1; j<blobs.length; j++){
            const a = blobs[i], c = blobs[j];

            const ax = a.x + a.r, ay = a.y + a.r;
            const bx = c.x + c.r, by = c.y + c.r;

            const dx = bx - ax, dy = by - ay;
            const dist = Math.hypot(dx,dy) || 0.0001;

            const minDist = (a.r + c.r) + GAP + VISUAL_GAP;

            if (dist < minDist){
              const overlap = (minDist - dist);
              const ux = dx / dist, uy = dy / dist;

              const sep = overlap * SEPARATE_RATIO * 0.5;
              a.x -= ux * sep; a.y -= uy * sep;
              c.x += ux * sep; c.y += uy * sep;

              // gentle repel so they stop re-clumping
              const force = overlap * REPEL;
              a.vx -= ux * force; a.vy -= uy * force;
              c.vx += ux * force; c.vy += uy * force;
            }
          }
        }
      }

      // 3) integrate + walls
      blobs.forEach(o => {
        o.vx *= DAMP;
        o.vy *= DAMP;

        o.x += o.vx;
        o.y += o.vy;

        const maxX = Math.max(b.maxXFor(o.size), b.minX);
        const maxY = Math.max(b.maxYFor(o.size), b.minY);

        if (o.x < b.minX){ o.x = b.minX; o.vx = Math.abs(o.vx) * BOUNCE; }
        if (o.x > maxX){ o.x = maxX; o.vx = -Math.abs(o.vx) * BOUNCE; }
        if (o.y < b.minY){ o.y = b.minY; o.vy = Math.abs(o.vy) * BOUNCE; }
        if (o.y > maxY){ o.y = maxY; o.vy = -Math.abs(o.vy) * BOUNCE; }

        o.el.style.transform = `translate(${o.x}px, ${o.y}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
})();
</script>

</body>
</html>
