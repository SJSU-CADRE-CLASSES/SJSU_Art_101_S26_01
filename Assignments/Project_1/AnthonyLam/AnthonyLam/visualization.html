<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DIGITAL RESIDUE — Visualization</title>
  <link rel="stylesheet" href="./style.css?v=1010">
</head>

<body data-page="viz">

<a class="back" href="./index.html">← BACK</a>

<h1 class="viz-title">MY SCREEN TIME</h1>
<p class="viz-sub">TAP / CLICK A COLOR BLOB TO REVEAL THE APP + SCREENTIME.</p>

<div id="blob-stage"></div>
<div id="tip" class="tip"></div>

<script src="./data.js?v=1010"></script>

<script>
const stage = document.getElementById("blob-stage");
const tip = document.getElementById("tip");
const ITEMS = (typeof APPS !== "undefined") ? APPS : [];

if (!ITEMS.length) {
  stage.innerHTML = `<p style="opacity:.7">No APPS data found in data.js.</p>`;
} else {

  // ===== TUNING =====
  const PAD = 24;

  // Separation (bigger = farther apart; VISUAL_GAP accounts for blur)
  const GAP = 320;
  const VISUAL_GAP = 48;

  // Solver (higher = less touching)
  const SOLVER_PASSES = 26;
  const SEPARATE_RATIO = 0.85;   // stronger hard-separation (prevents “near touching”)

  // Motion (screensaver vibe)
  const DRIFT = 0.16;            // more roaming force
  const WANDER = 0.06;           // more randomness
  const DAMP = 0.996;            // keeps momentum
  const BOUNCE = 1.02;           // a little extra bounce so it keeps moving

  // Speed control
  const MIN_SPEED = 2.2;         // ensures they don't “sit”
  const MAX_SPEED = 9.0;         // lava lamp / screensaver speed (cap)

  // Repulsion (lower than before to avoid “darting”, but enough to stay apart)
  const REPEL = 0.010;

  // Tooltip timing
  const TIP_MS = 3000;

  const maxH = Math.max(...ITEMS.map(x => Number(x.hours || 0)), 1);

  const blobs = [];
  const placed = [];
  let activeIndex = -1;

  let tipTimer = null;
  function showTip(text, x, y){
    // reset any old timer
    if (tipTimer) { clearTimeout(tipTimer); tipTimer = null; }

    tip.textContent = text;
    tip.style.opacity = "1";

    if (typeof x === "number" && typeof y === "number"){
      tip.style.left = (x + 14) + "px";
      tip.style.top  = (y + 14) + "px";
    }

    // auto-hide after 3s
    tipTimer = setTimeout(() => {
      tip.style.opacity = "0";
      activeIndex = -1;
      document.querySelectorAll(".blob").forEach(b => b.classList.remove("dim","active"));
      tipTimer = null;
    }, TIP_MS);
  }

  function clearTip(){
    if (tipTimer) { clearTimeout(tipTimer); tipTimer = null; }
    tip.style.opacity = "0";
  }

  function tryPlace(sizePx){
    const rect = stage.getBoundingClientRect();
    const r = sizePx/2;

    const minX = PAD;
    const minY = PAD;
    const maxX = rect.width  - sizePx - PAD;
    const maxY = rect.height - sizePx - PAD;

    // NOTE: if your screen is small + many blobs, a huge GAP can make placement hard.
    // Solver will still enforce separation after.
    for (let attempt = 0; attempt < 3200; attempt++){
      const x = minX + Math.random() * Math.max(maxX - minX, 1);
      const y = minY + Math.random() * Math.max(maxY - minY, 1);

      const cx = x + r;
      const cy = y + r;

      let ok = true;
      for (const p of placed){
        const dist = Math.hypot(cx - p.cx, cy - p.cy);
        const minDist = r + p.r + GAP + VISUAL_GAP;
        if (dist < minDist){ ok=false; break; }
      }

      if (ok){
        placed.push({cx, cy, r});
        return {x, y};
      }
    }

    return {
      x: minX + Math.random() * Math.max(maxX - minX, 1),
      y: minY + Math.random() * Math.max(maxY - minY, 1),
    };
  }

  function setActive(idx, clientX, clientY){
    activeIndex = idx;

    showTip(blobs[idx].label, clientX, clientY);

    document.querySelectorAll(".blob").forEach(b => b.classList.add("dim"));
    blobs[idx].el.classList.remove("dim");
    blobs[idx].el.classList.add("active");
  }

  // build blobs
  ITEMS.forEach((item, idx) => {
    const h = Number(item.hours || 0);

    // KEEP SIZE
    const size = 240 + (h/maxH) * 360;
    const r = size/2;

    const el = document.createElement("div");
    el.className = "blob";
    el.style.width = size + "px";
    el.style.height = size + "px";
    el.style.background = `radial-gradient(circle, ${item.color} 0%, rgba(255,255,255,0) 68%)`;

    stage.appendChild(el);

    const pos = tryPlace(size);

    // give each blob a strong initial velocity so it immediately roams
    const ang = Math.random() * Math.PI * 2;
    const sp  = MIN_SPEED + Math.random() * 3.2;

    blobs.push({
      el, size, r,
      x: pos.x, y: pos.y,
      vx: Math.cos(ang) * sp,
      vy: Math.sin(ang) * sp,
      phase: Math.random() * Math.PI * 2,
      label: `${item.app} — ${h.toFixed(1)} HOURS`
    });

    // click/tap only
    el.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      setActive(idx, e.clientX, e.clientY);
    });
  });

  // click/tap empty area clears immediately
  stage.addEventListener("pointerdown", (e)=>{
    if (e.target === stage){
      activeIndex = -1;
      clearTip();
      document.querySelectorAll(".blob").forEach(b => b.classList.remove("dim","active"));
    }
  });

  function animate(){
    const rect = stage.getBoundingClientRect();

    // drift + wander + enforce min/max speed
    blobs.forEach(o => {
      o.phase += 0.018;

      o.vx += Math.cos(o.phase) * DRIFT;
      o.vy += Math.sin(o.phase * 1.21) * DRIFT;

      o.vx += (Math.random() - 0.5) * WANDER;
      o.vy += (Math.random() - 0.5) * WANDER;

      // clamp max speed
      let sp = Math.hypot(o.vx, o.vy);
      if (sp > MAX_SPEED){
        const s = MAX_SPEED / sp;
        o.vx *= s; o.vy *= s;
        sp = MAX_SPEED;
      }

      // enforce min speed (keeps them roaming)
      if (sp < MIN_SPEED){
        const s = MIN_SPEED / Math.max(sp, 0.0001);
        o.vx *= s; o.vy *= s;
      }
    });

    // multi-pass separation solver (hard no-touch)
    for (let pass = 0; pass < SOLVER_PASSES; pass++){
      for (let i=0; i<blobs.length; i++){
        for (let j=i+1; j<blobs.length; j++){
          const a = blobs[i], b = blobs[j];

          const ax = a.x + a.r, ay = a.y + a.r;
          const bx = b.x + b.r, by = b.y + b.r;

          const dx = bx - ax, dy = by - ay;
          const dist = Math.hypot(dx,dy) || 0.0001;

          const minDist = (a.r + b.r) + GAP + VISUAL_GAP;

          if (dist < minDist){
            const overlap = (minDist - dist);
            const ux = dx / dist, uy = dy / dist;

            // Strong position separation (prevents “next to each other”)
            const sep = overlap * SEPARATE_RATIO * 0.5;
            a.x -= ux * sep; a.y -= uy * sep;
            b.x += ux * sep; b.y += uy * sep;

            // Mild velocity repulsion (keeps them from drifting back together)
            const force = overlap * REPEL;
            a.vx -= ux * force; a.vy -= uy * force;
            b.vx += ux * force; b.vy += uy * force;
          }
        }
      }
    }

    // integrate + walls
    blobs.forEach(o => {
      o.vx *= DAMP;
      o.vy *= DAMP;

      o.x += o.vx;
      o.y += o.vy;

      const minX = PAD;
      const minY = PAD;
      const maxX = rect.width  - o.size - PAD;
      const maxY = rect.height - o.size - PAD;

      if (o.x < minX){ o.x = minX; o.vx = Math.abs(o.vx) * BOUNCE; }
      if (o.x > maxX){ o.x = maxX; o.vx = -Math.abs(o.vx) * BOUNCE; }
      if (o.y < minY){ o.y = minY; o.vy = Math.abs(o.vy) * BOUNCE; }
      if (o.y > maxY){ o.y = maxY; o.vy = -Math.abs(o.vy) * BOUNCE; }

      o.el.style.transform = `translate(${o.x}px, ${o.y}px)`;
    });

    requestAnimationFrame(animate);
  }

  animate();
}
</script>

</body>
</html>
