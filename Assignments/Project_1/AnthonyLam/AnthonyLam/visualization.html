<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DIGITAL RESIDUE — Visualization</title>
  <link rel="stylesheet" href="./style.css?v=1006">
</head>

<body data-page="viz">

<a class="back" href="./index.html">← BACK</a>

<h1 class="viz-title">MY SCREEN TIME</h1>
<p class="viz-sub">HOVER OVER A COLOR BLOB TO REVEAL THE SCREENTIME.</p>

<div id="blob-stage"></div>
<div id="tip" class="tip"></div>

<script src="./data.js?v=1006"></script>

<script>
const stage = document.getElementById("blob-stage");
const tip = document.getElementById("tip");
const ITEMS = (typeof APPS !== "undefined") ? APPS : [];

if (!ITEMS.length) {
  stage.innerHTML = `<p style="opacity:.7">No APPS data found in data.js.</p>`;
} else {

  // ===== TUNING (change these if needed) =====
  const PAD = 40;            // keeps blobs away from stage edges
  const GAP = 170;           // BIGGER = more separation (prevents blur-touch)
  const REPEL = 0.018;       // stronger push-apart
  const DAMP = 0.975;        // closer to 1 = slower movement
  const BOUNCE = 0.90;       // wall bounce energy
  const DRIFT = 0.040;       // smooth lava drift amount
  const ACTIVE_REPEL = 1.55; // extra repel when one is active

  const maxH = Math.max(...ITEMS.map(x => Number(x.hours || 0)), 1);

  const blobs = [];
  const placed = [];

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // ---------- initial placement (more strict so they start apart) ----------
  function tryPlace(sizePx){
    const rect = stage.getBoundingClientRect();
    const r = sizePx/2;

    const minX = PAD;
    const minY = PAD;
    const maxX = rect.width  - sizePx - PAD;
    const maxY = rect.height - sizePx - PAD;

    for (let attempt = 0; attempt < 1600; attempt++){
      const x = minX + Math.random() * Math.max(maxX - minX, 1);
      const y = minY + Math.random() * Math.max(maxY - minY, 1);

      const cx = x + r;
      const cy = y + r;

      let ok = true;
      for (const p of placed){
        const dist = Math.hypot(cx - p.cx, cy - p.cy);
        const minDist = r + p.r + GAP;
        if (dist < minDist){ ok=false; break; }
      }

      if (ok){
        placed.push({cx, cy, r});
        return {x, y};
      }
    }

    // fallback (physics will still separate them)
    const x = minX + Math.random() * Math.max(maxX - minX, 1);
    const y = minY + Math.random() * Math.max(maxY - minY, 1);
    return {x, y};
  }

  // ---------- active behavior (push others away + dim) ----------
  let activeIndex = -1;

  function setActive(idx, labelText){
    activeIndex = idx;

    tip.textContent = labelText;
    tip.style.opacity = "1";

    document.querySelectorAll(".blob").forEach(b => b.classList.add("dim"));
    blobs[idx].el.classList.remove("dim");
    blobs[idx].el.classList.add("active");
  }

  function clearActive(){
    activeIndex = -1;
    tip.style.opacity = "0";
    document.querySelectorAll(".blob").forEach(b => b.classList.remove("dim","active"));
  }

  // ---------- build blobs ----------
  ITEMS.forEach((item, idx) => {
    const h = Number(item.hours || 0);

    // keep big, but feasible to separate
    const size = 240 + (h/maxH) * 360;
    const r = size/2;

    const el = document.createElement("div");
    el.className = "blob";
    el.style.width = size + "px";
    el.style.height = size + "px";
    el.style.background = `radial-gradient(circle, ${item.color} 0%, rgba(255,255,255,0) 72%)`;

    stage.appendChild(el);

    const pos = tryPlace(size);

    blobs.push({
      el,
      size,
      r,
      x: pos.x,
      y: pos.y,
      vx: (Math.random()-0.5) * 0.9,
      vy: (Math.random()-0.5) * 0.9,
      phase: Math.random() * Math.PI * 2,
      speed: 0.006 + Math.random() * 0.010,
      label: `${item.app} — ${h.toFixed(1)} HOURS`
    });

    const show = () => setActive(idx, blobs[idx].label);

    el.addEventListener("mouseenter", show);
    el.addEventListener("click", show);
    el.addEventListener("touchstart", (e)=>{ e.preventDefault(); show(); }, {passive:false});
    el.addEventListener("mouseleave", clearActive);
  });

  // ---------- tooltip follows mouse ----------
  document.addEventListener("mousemove",(e)=>{
    tip.style.left=(e.clientX+14)+"px";
    tip.style.top =(e.clientY+14)+"px";
  });

  stage.addEventListener("click",(e)=>{
    if (e.target === stage) clearActive();
  });

  // ---------- physics loop (repel ALWAYS + smooth drift + wall bounce) ----------
  function animate(){
    const rect = stage.getBoundingClientRect();

    // smooth drift (lava feel, not sway)
    blobs.forEach(o => {
      o.phase += o.speed;
      o.vx += Math.cos(o.phase) * DRIFT;
      o.vy += Math.sin(o.phase * 1.07) * DRIFT;
    });

    // repel all pairs
    for (let i=0; i<blobs.length; i++){
      for (let j=i+1; j<blobs.length; j++){
        const a = blobs[i];
        const b = blobs[j];

        const ax = a.x + a.r;
        const ay = a.y + a.r;
        const bx = b.x + b.r;
        const by = b.y + b.r;

        let dx = bx - ax;
        let dy = by - ay;
        let dist = Math.hypot(dx,dy) || 0.0001;

        const activeBoost =
          (i === activeIndex || j === activeIndex) ? ACTIVE_REPEL : 1;

        const minDist = a.r + b.r + GAP * activeBoost;

        if (dist < minDist){
          const overlap = (minDist - dist);
          const force = overlap * REPEL;

          const ux = dx / dist;
          const uy = dy / dist;

          a.vx -= ux * force;
          a.vy -= uy * force;
          b.vx += ux * force;
          b.vy += uy * force;
        }
      }
    }

    // integrate + damping + walls
    blobs.forEach((o, idx) => {
      o.vx *= DAMP;
      o.vy *= DAMP;

      o.x += o.vx;
      o.y += o.vy;

      const minX = PAD;
      const minY = PAD;
      const maxX = rect.width  - o.size - PAD;
      const maxY = rect.height - o.size - PAD;

      if (o.x < minX){ o.x = minX; o.vx = Math.abs(o.vx) * BOUNCE; }
      if (o.x > maxX){ o.x = maxX; o.vx = -Math.abs(o.vx) * BOUNCE; }
      if (o.y < minY){ o.y = minY; o.vy = Math.abs(o.vy) * BOUNCE; }
      if (o.y > maxY){ o.y = maxY; o.vy = -Math.abs(o.vy) * BOUNCE; }

      // render with transform (smooth)
      o.el.style.transform = `translate(${o.x}px, ${o.y}px)`;
    });

    requestAnimationFrame(animate);
  }

  animate();
}
</script>

</body>
</html>
